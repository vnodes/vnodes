export enum Annotation {
    /**
     * Max value or max length
     */
    max = 'max',

    /**
     * Min value or min length
     */
    min = 'min',

    /**
     * Minimum allowed text length
     */
    minLength = 'minLength',

    /**
     * Maximum allowed text length
     */
    maxLength = 'maxLength',

    /**
     * Maximum items allowed for array field
     */
    maxItems = 'maxItems',

    /**
     * Minimum items allowed for array field
     */
    minItems = 'minItems',

    /**
     * Value format such as password, email
     */
    format = 'format',

    /**
     * Check currentDate.year - inputDate.year < maxAge
     */
    maxAge = 'maxAge',

    /**
     * Check currentDate.year - inputDate.year > minAge
     */
    minAge = 'minAge',

    /**
     * Check the user input is future date
     */
    future = 'future',

    /**
     * Check the user input is a past date
     */
    past = 'past',

    /**
     * Define that the field is not a user input and set by the system
     */
    internal = 'internal',

    /**
     * Define that the field is not a user input and generated by the system
     */
    generated = 'generated',

    /**
     * Disable projection for relation and field
     */
    hidden = 'hidden',

    /**
     * Disable update
     */
    readonly = 'readonly',

    /**
     * Disable read
     */
    writeonly = 'writeonly',

    /**
     * Enable relation query
     */
    query = 'query',

    /**
     * Mark the relation as child relation
     */
    child = 'child',

    /**
     * Mark the relation as parent relation
     */
    parent = 'parent',

    /**
     * Mark the relation is attribute realtion
     */
    attribute = 'attribute',

    /**
     * Enable projection for the relation field
     */
    projection = 'projection',

    /**
     * Add description for the field
     */
    description = 'description',

    /**
     * Include the relation relation
     */
    include = 'include',

    /**
     * Mark the field to be hashed
     */
    hash = 'hash',

    deletedAt = 'deletedAt',
}

export type AnnotationName = keyof typeof Annotation;

export function validateDocumentation(text: string) {
    const foundNotations = [...text.matchAll(/@([a-zA-Z]+)\(.*?\)/g)].map((e) => e[1].toLowerCase());
    const actualNotations = Object.keys(Annotation).map((e) => e.toLowerCase());

    for (const found of foundNotations) {
        if (!actualNotations.find((aa) => aa === found)) {
            console.log(`${found} annotations is not recognized in "${text}"`);
        }
    }
}

export function __createFieldAnnotationExpression(key: string) {
    // /@(\w+)\(([^)]+)\)/g
    return new RegExp(`@${key}\\(([^)]+)\\)`, 'i');
}

export type AnnotationExtractionFn = (text?: string) => RegExpMatchArray | null | undefined;

export type AnnotationExtractors = Record<Annotation, AnnotationExtractionFn>;

export const Annotations = Object.values(Annotation).reduce<AnnotationExtractors>((acc, value) => {
    acc[value] = (text?: string) => {
        if (text) {
            text = text.replace(/\(\)/g, '(true)');
        }

        const result = text?.match(__createFieldAnnotationExpression(value));
        return result;
    };
    return acc;
}, {} as AnnotationExtractors);
